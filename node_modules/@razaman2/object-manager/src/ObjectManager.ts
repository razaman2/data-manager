import type {ReadOptions, WriteOptions, Parseable, Options} from "./Types";

export default class ObjectManager {
    private readonly skipped = [Date];

    constructor(private object : Parseable = {}, private options : Options = {}) {
        this.skipped = (options.skip === false) ? [] : this.skipped.concat(options.skip ?? []);
    }

    public paths(object = this.object, path? : string) {
        return Object.entries(object).reduce((paths : Array<string>, [key, val] : [string, Parseable]) => {
            const previous = {path: `${path ? `${path}.` : ""}${key}`};

            if (this.options.paths?.test?.(previous.path) ?? true) {
                if ((typeof val === "object")) {
                    try {
                        if (((typeof this.options.functions === "boolean") ? this.options.functions : true) && Object.values(val).some((item) => typeof item === "function")) {
                            paths.push(key);
                        } else {
                            const nested = {paths: this.paths(val, previous.path)};

                            if ((nested.paths.length === 0) || this.options.paths?.full) {
                                paths.push(key);
                            }

                            nested.paths.forEach((segment) => {
                                paths.push(`${key}.${segment}`);
                            });
                        }
                    } catch (e) {
                        paths.push(key);
                    }
                } else {
                    paths.push(key);
                }
            }

            return paths;
        }, []);
    };

    public get() : any
    public get(options : ReadOptions) : any
    public get(path : string | number, alternative? : any) : any
    public get(param1? : string | number | ReadOptions, param2? : any) {
        const {path, alternative, object = this.object}
            = ((typeof param1 === "string") || (typeof param1 === "number"))
            ? {path: param1, alternative: param2}
            : (param1 ?? {});

        if (typeof path === "number") {
            return this.get(path.toString(), param2);
        } else if (typeof path === "string") {
            try {
                return path.split(".").reduce((object, segment) => {
                    return object[segment];
                }, object) ?? alternative;
            } catch (e) {
                return alternative;
            }
        } else {
            return object.hasOwnProperty("") ? object[""] : param1?.hasOwnProperty("alternative") ? alternative : object;
        }
    };

    public set(value : any) : Parseable
    public set(options : WriteOptions) : Parseable
    public set(path : string | number, value : any) : Parseable
    public set(param1 : string | number | WriteOptions, param2? : any) {
        if (arguments.length === 1) {
            if (typeof param1 === "object") {
                if (param1.hasOwnProperty("value")) {
                    if (param1.hasOwnProperty("path")) {
                        this.set(param1.path!, param1.value);
                    } else {
                        this.set(param1.value);
                    }
                } else if (param1.hasOwnProperty("object")) {
                    this.copy(param1.object);
                } else {
                    this.copy(param1);
                }
            } else {
                this.set("", param1);
            }
        } else {
            if (typeof param1 === "number") {
                this.set(param1.toString(), param2);
            } else if (typeof param1 === "string") {
                param1.split(".").reduce((object, segment, index, segments) => {
                    if (index === (segments.length - 1)) {
                        object[segment] = param2;
                    } else if (object.hasOwnProperty(segment)) {
                        return object[segment];
                    } else {
                        object[segment] = RegExp(`${segment}\.\\d+(?:\\.|$)`).test(param1) ?
                            [] : ((typeof param2 === "object") ? Object.setPrototypeOf({}, Object.getPrototypeOf(param2)) : {});
                    }

                    return object[segment];
                }, this.object);
            } else {
                throw new Error(JSON.stringify({
                    code: "invalid_path",
                    message: "path must be typeof string or number.",
                }));
            }
        }

        return this.object;
    };

    public copy(object : Parseable) {
        this.object = ObjectManager.on(object).clone();

        return this;
    }

    public clone(object : Parseable = this.object) {
        if (this.skip(object)) {
            return object;
        } else {
            return Object.setPrototypeOf(
                Object.entries(object).reduce((object : Parseable, [key, val]) => {
                    try {
                        if (Array.isArray(val)) {
                            object[key] = val.map((item) => {
                                if (typeof item === "object") {
                                    return Object.setPrototypeOf(this.clone(item), Object.getPrototypeOf(item));
                                } else {
                                    return item;
                                }
                            });
                        } else if (typeof val === "object") {
                            object[key] = Object.setPrototypeOf(this.clone(val), Object.getPrototypeOf(val));
                        } else {
                            object[key] = val;
                        }
                    } catch (e) {
                        object[key] = val;
                    }

                    return object;
                }, Array.isArray(object) ? [] : {}),

                Object.getPrototypeOf(object),
            );
        }
    }

    public static on(object : Parseable = {}, options : Options = {}) {
        return new ObjectManager(object, options);
    }

    private skip(object : any) {
        for (const item of this.skipped) {
            if (object instanceof item) {
                return true;
            }
        }

        return false;
    }
}
