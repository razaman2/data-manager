import {v4 as uuid} from 'uuid';
import type {EventTypes, Eventable} from "./Types";

type Handler = Array<Function> | Function

export default class EventEmitter {
    private emitter: {
        id: string
        events: Array<Eventable>
    } = {id: uuid(), events: []};

    get id() {
        return this.emitter.id;
    }

    get events() {
        return this.emitter.events;
    }

    set events(events) {
        this.emitter.events = events;
    }

    public on(subscriptions: string | Record<string, Handler>, handlers?: Handler) {
        return this.register(subscriptions, handlers);
    }

    public once(subscriptions: string | Record<string, Handler>, handlers?: Handler) {
        return this.register(subscriptions, handlers, 'once');
    }

    public off(subscriptions: string, type?: EventTypes) {
        this.remove(subscriptions, type);
    }

    public emit(subscription?: string, ...params: any) {
        return new Promise(async (resolve) => {
            const events = subscription ? this.events.filter((event) => event.name === subscription) : this.events;

            const promises = events.reduce((handlers: Array<Promise<any>>, event) => {
                event.handlers.forEach((handler) => handlers.push(this.invoke(event.name, handler, params)));

                if (event.type === 'once') {
                    this.off(event.name, event.type);
                }

                return handlers;
            }, []);

            resolve(await Promise.all(promises));
        });
    }

    private register(subscriptions: string | Record<string, Handler>, handlers?: Handler, type: EventTypes = 'standard') {
        if (handlers && (typeof subscriptions === "string")) {
            subscriptions = {[subscriptions]: handlers};
        }

        return Object.entries(subscriptions).reduce((subscriptions: Record<string, Function>, [subscription, handlers]) => {
            if (subscription.length) {
                this.events.push({
                    type,
                    name: subscription,
                    handlers: Array.isArray(handlers) ? handlers : [handlers],
                });

                subscriptions[subscription] = () => this.off(subscription);
            }

            return subscriptions;
        }, {});
    }

    private remove(subscription: string, type?: EventTypes) {
        this.events = this.events.filter((event) => {
            return !((event.name === subscription) && (type ? (event.type === type) : true))
        });
    }

    private invoke(subscription: string, handler: Function, params: Array<any>) {
        try {
            return handler(...params);
        } catch (e) {
            return this.emit('@error', {
                subscription,
                details: e,
            });
        }
    }
}
